"use strict";(self.webpackChunkcommerce_pwa_studio=self.webpackChunkcommerce_pwa_studio||[]).push([[3382],{9621:function(e,t,a){a.r(t),a.d(t,{_frontmatter:function(){return l},default:function(){return p}});var n=a(87462),r=a(45987),s=(a(35776),a(3905)),o=a(91515);const i=["components"],l={},d={_frontmatter:l},c=o.Z;function p(e){let{components:t}=e,a=(0,r.Z)(e,i);return(0,s.mdx)(c,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,s.mdx)("h1",{id:"targets-and-targetables"},"Targets and Targetables"),(0,s.mdx)("p",null,"Targets and Targetables are features provided by PWA Studio's ",(0,s.mdx)("a",{parentName:"p",href:"/commerce-pwa-studio/guides/general-concepts/extensibility/"},"extensibility framework"),".\nThey give you the ability to change feature behaviors, component logic, and even component source code without editing a local copy of PWA Studio code."),(0,s.mdx)("h2",{id:"intercept-file"},"Intercept file"),(0,s.mdx)("p",null,"The intercept file is where you directly interact with Targets and Targetables to apply customizations.\nIt exports a default function that accepts a TargetProvider parameter."),(0,s.mdx)("h3",{id:"intercept-file-name-and-location"},"Intercept file name and location"),(0,s.mdx)("p",null,"The file name and location of your intercept file is a custom value you specify in your project's ",(0,s.mdx)("inlineCode",{parentName:"p"},"package.json")," file."),(0,s.mdx)("p",null,"To register the location of your intercept file, set the value for ",(0,s.mdx)("inlineCode",{parentName:"p"},"pwa-studio.targets.intercept"),".\nFor example, the following entry registers ",(0,s.mdx)("inlineCode",{parentName:"p"},"src/targets/intercept.js")," as this project's intercept file."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-json"},'"pwa-studio": {\n    "targets": {\n      "intercept": "src/targets/intercept"\n    }\n}\n')),(0,s.mdx)("h3",{id:"how-interception-works"},"How interception works"),(0,s.mdx)("p",null,"Interception logic executes during the build process.\nThe ",(0,s.mdx)("inlineCode",{parentName:"p"},"@magento/pwa-buildpack")," module creates a BuildBus process to run intercept files in the storefront project or its dependencies."),(0,s.mdx)("p",null,"The BuildBus process executes intercept files in ",(0,s.mdx)("strong",{parentName:"p"},"named direct dependencies")," in a project.\nThis means that modules listed under ",(0,s.mdx)("inlineCode",{parentName:"p"},"dependencies")," and ",(0,s.mdx)("inlineCode",{parentName:"p"},"devDependencies")," in a project's ",(0,s.mdx)("inlineCode",{parentName:"p"},"package.json")," file have the ability to intercept Targets and Targetables in the project.\nThe process does not execute intercept files in dependencies beyond those modules in the dependency tree."),(0,s.mdx)("h3",{id:"interception-order"},"Interception order"),(0,s.mdx)("p",null,"The interception process executes files in dependency order.\nThis means that if your module declares another module that has an intercept file as a peer dependency, the other module's intercept file executes first."),(0,s.mdx)("h2",{id:"target"},"Target"),(0,s.mdx)("p",null,"A ",(0,s.mdx)("em",{parentName:"p"},"Target")," is a formal extension point exposed by a package.\nBuildpack, Peregrine, and Venia UI expose their own set of Targets that let developers change the behavior of the underlying code.\nTargets are a package's public API and can be intercepted in storefront or extension projects."),(0,s.mdx)("h3",{id:"intercepting-targets"},"Intercepting Targets"),(0,s.mdx)("p",null,"Use the TargetProvider given to the intercept file's default function to access Targets from your project's dependencies."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},'module.exports = (targets) => {\n  // Set buildpack features\n  const builtins = targets.of("@magento/pwa-buildpack");\n  builtins.specialFeatures.tap((featuresByModule) => {\n    featuresByModule["my-extension"] = {\n      // Tells buildpack that this extension uses ES Modules\n      esModules: true,\n    };\n  });\n};\n')),(0,s.mdx)("h3",{id:"pwa-studio-target-reference"},"PWA Studio target reference"),(0,s.mdx)("p",null,"The following PWA Studio packages contain Targets that developers can intercept:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"/commerce-pwa-studio/api/buildpack/targets/"},"Buildpack")),(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"/commerce-pwa-studio/api/peregrine/extension-points/targets/"},"Peregrine")),(0,s.mdx)("li",{parentName:"ul"},(0,s.mdx)("a",{parentName:"li",href:"/commerce-pwa-studio/api/venia/targets/"},"Venia UI"))),(0,s.mdx)("h2",{id:"targetables"},"Targetables"),(0,s.mdx)("p",null,(0,s.mdx)("em",{parentName:"p"},"Targetables")," are objects that give you access to the source code for the files in your project or library.\nThey let you change the final application bundles by applying transformations to the source code during the build process."),(0,s.mdx)("p",null,"Targetables are useful in two scenarios:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},"As a ",(0,s.mdx)("strong",{parentName:"li"},"storefront developer"),", you can use Targetables to transform the source file in any of your project's dependencies."),(0,s.mdx)("li",{parentName:"ul"},"As an ",(0,s.mdx)("strong",{parentName:"li"},"extension developer"),", you can use Targetables to add Targets to your own extension.")),(0,s.mdx)("h3",{id:"access-the-targetableset-class"},"Access the TargetableSet class"),(0,s.mdx)("p",null,"The most common pattern for working with Targetable objects is to connect an instance of the ",(0,s.mdx)("a",{parentName:"p",href:"/commerce-pwa-studio/api/buildpack/targetables/TargetableSet/"},"TargetableSet")," to the TargetProvider sent to the intercept file.\nThen, you can use that instance to create Targetable objects."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},'// Access the TargetableSet class\nconst { Targetables } = require("@magento/pwa-buildpack");\n\nmodule.exports = (targets) => {\n  // Create a TargetableSet instance connected to this project\'s TargetProvider\n  const targetables = Targetables.using(targets);\n\n  // Use the TargetableSet to create Targetable objects\n};\n')),(0,s.mdx)("h3",{id:"create-targetable-objects"},"Create Targetable objects"),(0,s.mdx)("p",null,"Use the TargetableSet instance to create a ",(0,s.mdx)("a",{parentName:"p",href:"/commerce-pwa-studio/api/buildpack/targetables/TargetableModule/"},"TargetableModule")," class object or one of its subclasses.\nThe TargetableModule class itself represents a plain module.\nIt contains functions that let it manipulate the source code directly."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},'const { Targetables } = require("@magento/pwa-buildpack");\n\nmodule.exports = (targets) => {\n  const targetables = Targetables.using(targets);\n\n  // Create a TargetableModule instance that points to the main.js source\n  const MainComponent = targetables.module(\n    "@magento/venia-ui/lib/components/Main/main.js"\n  );\n\n  // Insert a console log message in the source\n  MainComponent.insertAfterSource(\n    "const Main = props => {\\n",\n    \'\\tconsole.log("Hello World");\\n\'\n  );\n};\n')),(0,s.mdx)("p",null,"Other Targetable classes, such as ",(0,s.mdx)("a",{parentName:"p",href:"/commerce-pwa-studio/api/buildpack/targetables/TargetableESModule/"},"TargetableESModule"),", are subclasses of TargetableModule.\nThey contain specialized functions that let it work with different modules or file types."),(0,s.mdx)("h3",{id:"chain-transformations"},"Chain transformations"),(0,s.mdx)("p",null,"Some Targetable classes, such as TargetableModule and ",(0,s.mdx)("a",{parentName:"p",href:"/commerce-pwa-studio/api/buildpack/targetables/TargetableReactComponent/"},"TargetableReactComponent"),", support method chaining.\nCertain methods in these classes are chainable, which let you call these methods one after another in your code."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},'const { Targetables } = require("@magento/pwa-buildpack");\n\nmodule.exports = (targets) => {\n  const targetables = Targetables.using(targets);\n\n  const MainComponent = targetables.reactComponent(\n    "@magento/venia-ui/lib/components/Main/main.js"\n  );\n\n  MainComponent.appendJSX(\n    "div className={pageClass}",\n    "<span>appendJSX succeeded!</span>"\n  )\n    .addJSXClassName("Header", \'"myClass"\')\n    .insertBeforeJSX("<Header />", "<span>insertBeforeJSX succeeded!</span>");\n};\n')),(0,s.mdx)("h3",{id:"unbound-targetable-objects"},"Unbound Targetable objects"),(0,s.mdx)("p",null,"A less common pattern for using Targetables is to access the Targetables classes directly and creating an object that is not connected to a project's TargetProvider."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},'const { Targetables } = require("@magento/pwa-buildpack");\n\nmodule.exports = (targets) => {\n  // Create an unbound Targetable ESModule object from a file\n  const handlers = new Targetables.ESModule("src/lib/handlers.js");\n\n  // Wrap an export in a decorator from another file\n  handlers.wrapWithFile("handleLoad", "src/overrides/doSomethingOnLoad.js");\n\n  // Send it all to the build\n  targets.of("@magento/pwa-buildpack").transformModules.tap((addTransform) => {\n    handlers.flush().forEach((request) => addTransform(request));\n  });\n};\n')))}p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-tutorials-targets-index-md-056d1531fbee003e0f89.js.map